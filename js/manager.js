function PixelManager(canvas){
  var pm = {};

  var context = canvas.getContext('2d');
  var fullImgData = context.getImageData(0, 0, canvas.width, canvas.height).data;
  var whitePixel = context.createImageData(1,1);
  whitePixel.data[0] = 255;
  whitePixel.data[1] = 255;
  whitePixel.data[2] = 255;
  whitePixel.data[3] = 255;
  var cache = Grid();

  pm.getPixel = function(x, y){
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height){
      return null;
    }
    var pixel = cache.get(x,y);
    if (pixel){
      return pixel;
    }

    var index = (y * canvas.width + x) * 4;
    pixel = Pixel(x,y,fullImgData,index);
    cache.setPixel(pixel);
    return pixel;
  }

  pm.getContiguousWhite = function(){
    var seen = Grid();
    var groups = [];

    function recur(pixel){
      var group = Group();
      var pendingLookup = [pixel];
      function lookup(p){
        // tried checking group size, caused browser crash
        if (!p){
          return;
        }
        if (seen.getPixel(p)){
          return;
        }
        seen.setPixel(p, true);
        if (!p.isWhite()){
          return;
        }
        group.setPixel(p);
        var neighbors = [
          pm.getPixel(p.x - 1, p.y),
          pm.getPixel(p.x + 1, p.y),
          pm.getPixel(p.x, p.y - 1),
          pm.getPixel(p.x, p.y + 1)
        ];
        neighbors.forEach(function (n){
          pendingLookup.push(n);
        });
      }
      while (pendingLookup.length > 0){
        var p = pendingLookup.pop();
        lookup(p);
      }
      return group;
    }

    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        if (!seen.get(x,y)){
          var pixel = pm.getPixel(x, y);
          var group = recur(pixel);
          if (group.size > 0){
            groups.push(group);
          }
        }
      }
    }
    return groups;
  }

  pm.getAllWhite = function(){
    // unused
    var group = Group();
    for (var x = 0; x < canvas.width; x++) {
      for (var y = 0; y < canvas.height; y++) {
        var pixel = pm.getPixel(x, y);
        if (pixel.isWhite()){
          group.setPixel(pixel);
        }
      }
    }
    return [group];
  }
  
  pm.vetGroups = function(groups){
    function vetGroup(group){
      // todo improve
      return group.size > 7000;
    }

    var valid = [];
    groups.forEach(function (g){
      if (vetGroup(g)){
        valid.push(g);
        po('group size: ' + g.size);
      }
    });
    return valid;
  }

  pm.replaceGroups = function(groups, fillImg){
    function replaceGroup(g){
      var slices = g.getHorizontalSlices();
      slices.forEach(function (s){
        for (var x = s.min; x <= s.max; x++){
          context.putImageData(whitePixel, x, s.y);
        }
      });
      var rect = g.rect;
      po(JSON.stringify(rect));
      context.drawImage(
        fillImg,
        rect.minX,
        rect.minY,
        rect.maxX - rect.minX,
        rect.maxY - rect.minY
      );
    }
    groups.forEach(function (g){
      if (g.size > 0){
        replaceGroup(g);
      }
    });
  }
  return pm;
}
