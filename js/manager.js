function PixelManager(canvas){
  var pm = {};
  var pv = {};

  var context = canvas.getContext('2d');
  var height = canvas.height;
  var width = canvas.width;
  var imgData = context.getImageData(0, 0, width, height);

  pm.getPixel = function(x, y){
    if (x < 0 || x >= width || y < 0 || y >= height){
      return null;
    }
    var index = (y * width + x) * 4;
    pixel = Pixel(x,y,imgData.data,index);
    return pixel;
  }

  pv.setPixelToWhite = function(x, y){
    var index = (y * width + x) * 4;
    for (var i = 0; i < 4; i++){
      imgData.data[index + i] = 255;
    }
  }

  pm.getContiguousWhite = function(){
    var seen = Grid();
    var groups = [];

    function recur(pixel){
      var group = Group();
      var pendingLookup = [pixel];
      function lookup(p){
        // tried checking group size, caused browser crash
        if (!p){
          return;
        }
        if (seen.getPixel(p)){
          return;
        }
        seen.setPixel(p, true);
        if (!p.isWhite()){
          return;
        }
        group.setPixel(p);
        var neighbors = [
          pm.getPixel(p.x - 1, p.y),
          pm.getPixel(p.x + 1, p.y),
          pm.getPixel(p.x, p.y - 1),
          pm.getPixel(p.x, p.y + 1)
        ];
        neighbors.forEach(function (n){
          pendingLookup.push(n);
        });
      }
      while (pendingLookup.length > 0){
        var p = pendingLookup.pop();
        lookup(p);
      }
      return group;
    }

    for (var x = 0; x < width; x++) {
      for (var y = 0; y < height; y++) {
        if (!seen.get(x,y)){
          var pixel = pm.getPixel(x, y);
          var group = recur(pixel);
          if (group.size() > 0){
            groups.push(group);
          }
        }
      }
    }
    return groups;
  }
  
  pm.vetGroups = function(groups){
    function vetGroup(group){
      // todo improve
      return group.size() > 7000;
    }

    var valid = [];
    groups.forEach(function (g){
      if (vetGroup(g)){
        valid.push(g);
        po('group size: ' + g.size);
      }
    });
    return valid;
  }

  pm.replaceGroups = function(groups, fillImg){
    groups.forEach(function (g){
      var slices = g.getHorizontalSlices();
      slices.forEach(function (s){
        for (var x = s.min; x <= s.max; x++){
          pv.setPixelToWhite(x, s.y);
        }
      });
    });
    context.putImageData(imgData, 0, 0);
    groups.forEach(function (g){
      var rect = g.rect;
      po(JSON.stringify(rect));
      context.drawImage(
        fillImg,
        rect.minX,
        rect.minY,
        rect.maxX - rect.minX,
        rect.maxY - rect.minY
      );
    });
  }
  return pm;
}
